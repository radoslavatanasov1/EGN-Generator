// Generated by CoffeeScript 1.11.1
var combinations, combinationsWithRepetitions, egnPermutations, fixWrongDigits, generateRandomOrPattern, generateRandomPattern, generateRandomRangePattern, generateRandomStarPattern, getEgnsFromModel, getOptimalPattern, getOptimalPatternGenerator, getOptimalRegionPattern, getOrPatterns, getPatternLength, getPatternsFromRangeModel, getRandomEgn, getRandomNumbers, numberOfEgns, pad, parseRange, permutations, product, remove, starPattern, swapTwoDigits, tooManyDigits, tryFixIt,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

getEgnsFromModel = function(model) {
  var getEgns;
  getEgns = function(p) {
    if (p.match(/^[\d\?]*\?[\d\?]*$/)) {
      return findEgnsWithPattern(p);
    } else if (p.match(/^\d+$/)) {
      return findEgns(parseEgn(p));
    }
  };
  if (model.match(/\([^()]+?\)/)) {
    return getOrPatterns(model).flatMap(function(p) {
      return getEgnsFromModel(p);
    });
  } else if (model.match(/^(\[.+?\]|[\d\?\*])*\*(\[.+?\]|[\d\?\*])*$/)) {
    return starPattern(model).flatMap(function(p) {
      return getEgnsFromModel(p);
    }).unique();
  } else if (model.match(/^[\d\?]*\[.+?\][\d\?]*$/)) {
    return getPatternsFromRangeModel(model).flatMap(function(p) {
      return getEgns(p);
    }).unique();
  } else {
    return getEgns(model);
  }
};

tryFixIt = function(egn, genFunc) {
  return filterEgns(genFunc(egn)).unique();
};

numberOfEgns = function(nYears) {
  return nYears * 365 * 1000 + (Math.floor(nYears / 4)) * 1 * 1000;
};

getRandomNumbers = function(n) {
  var j, results;
  if (n == null) {
    n = 10;
  }
  return (function() {
    results = [];
    for (var j = 1; 1 <= n ? j <= n : j >= n; 1 <= n ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this).map(function() {
    return parseInt(Math.random() * 10);
  });
};

generateRandomOrPattern = function(pattern) {
  return _.sample(getOrPatterns(pattern));
};

generateRandomStarPattern = function(pattern) {
  var gs, l, ns, ps, randomSum, result, s;
  if (!pattern.match(/\*/)) {
    return pattern;
  }
  l = 10 - getPatternLength(pattern);
  s = pattern.match(/\*/g).length;
  randomSum = function(n, len) {
    var x;
    if (len === 1) {
      return [n];
    } else {
      x = _.sample(_.range(n));
      return [x].concat(randomSum(n - x, len - 1));
    }
  };
  ns = getRandomNumbers(l);
  ps = randomSum(l, s);
  gs = ps.map(function(i) {
    var result;
    result = [];
    _.times(i, function() {
      return result.push(ns.shift());
    });
    return result.join('');
  });
  result = pattern;
  gs.forEach(function(g) {
    return result = result.replace('*', g);
  });
  return result;
};

generateRandomRangePattern = function(pattern) {
  var result, rs;
  if (!pattern.match(/\[.+?\]/)) {
    return pattern;
  }
  rs = pattern.match(/\[.+?\]/g).map(function(r) {
    return [r, parseRange(r)];
  });
  result = pattern;
  rs.forEach(function(it) {
    return result = result.replace(it[0], _.sample(it[1]));
  });
  return result;
};

generateRandomPattern = function(pattern) {
  var e, j, k, ns, ps, ref, ref1, results, results1;
  if (!pattern.match(/\?/)) {
    return pattern;
  }
  ps = (function() {
    results = [];
    for (var j = 0, ref = pattern.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this).filter(function(i) {
    return pattern[i] === '?';
  });
  e = (function() {
    results1 = [];
    for (var k = 0, ref1 = pattern.length; 0 <= ref1 ? k < ref1 : k > ref1; 0 <= ref1 ? k++ : k--){ results1.push(k); }
    return results1;
  }).apply(this).filter(function(i) {
    return pattern[i] !== '?';
  }).map(function(i) {
    return Number(pattern[i]);
  });
  ns = getRandomNumbers(ps.length);
  return fillAllPos(e, ns, ps).join('');
};

getRandomEgn = function(pattern) {
  var _dateOk, _genderOk, _regionOk, egn, ok;
  if (pattern == null) {
    pattern = '';
  }
  _genderOk = genderOk(getGender());
  _regionOk = regionOk(getRegion());
  _dateOk = dateOk(ageOk(getAgeRange()));
  ok = function(e) {
    return _genderOk(e) && egnOk(e) && _dateOk(e) && _regionOk(e);
  };
  if (_.isString(pattern)) {
    if (pattern === '') {
      while (true) {
        egn = getRandomNumbers();
        if (ok(egn)) {
          return egn;
        }
      }
    } else {
      while (true) {
        egn = parseEgn(generateRandomPattern(generateRandomRangePattern(generateRandomStarPattern(generateRandomOrPattern(pattern)))));
        if (ok(egn)) {
          return egn;
        }
      }
    }
  }
  if (_.isRegExp(pattern)) {
    while (true) {
      egn = getRandomNumbers();
      if (ok(egn) && pattern.test(egn.join(''))) {
        return egn;
      }
    }
  }
};

getOptimalPatternGenerator = function() {
  var addToMonth, computeLastDigit, currentMonth, getDays, j, maxAge, maxYear, minAge, minYear, months, ref, regions, results, years;
  ref = getAgeRange(), minAge = ref[0], maxAge = ref[1];
  minYear = moment().year() - maxAge - 1;
  maxYear = moment().year() - minAge;
  years = (function() {
    results = [];
    for (var j = minYear; minYear <= maxYear ? j <= maxYear : j >= maxYear; minYear <= maxYear ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this);
  months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
  regions = getPatternsFromRangeModel(getOptimalRegionPattern().replace(/\?/g, '[0-9]'));
  addToMonth = function(y, m) {
    switch (false) {
      case !(y < 1900):
        return m + 20;
      case !(y >= 2000):
        return m + 40;
      default:
        return m;
    }
  };
  getDays = function(month) {
    var k, o, q, results1, results2, results3;
    switch (month) {
      case 2:
        return (function() {
          results1 = [];
          for (k = 1; k <= 29; k++){ results1.push(k); }
          return results1;
        }).apply(this);
      case 1:
      case 3:
      case 5:
      case 7:
      case 8:
      case 10:
      case 12:
        return (function() {
          results2 = [];
          for (o = 1; o <= 31; o++){ results2.push(o); }
          return results2;
        }).apply(this);
      case 4:
      case 6:
      case 9:
      case 11:
        return (function() {
          results3 = [];
          for (q = 1; q <= 30; q++){ results3.push(q); }
          return results3;
        }).apply(this);
    }
  };
  computeLastDigit = function(e) {
    return [0, 1, 2, 3, 4, 5, 6, 7, 8].map(function(i) {
      return e[i] * Math.pow(2, i + 1) % 11;
    }).reduce(function(sum, n) {
      return sum + n;
    }) % 11 % 10;
  };
  currentMonth = function() {
    return moment().month() + 1;
  };
  return (function*() {
    var d, e, eDD, eMM, eYY, k, len1, len2, len3, len4, m, o, q, r, ref1, t, y;
    for (k = 0, len1 = years.length; k < len1; k++) {
      y = years[k];
      eYY = pad(y % 100, 2);
      for (o = 0, len2 = months.length; o < len2; o++) {
        m = months[o];
        if (y === minYear && m < currentMonth()) {
          continue;
        }
        if (y === maxYear && m > currentMonth()) {
          break;
        }
        eMM = pad(addToMonth(y, m), 2);
        ref1 = getDays(m);
        for (q = 0, len3 = ref1.length; q < len3; q++) {
          d = ref1[q];
          if (y === minYear && m === currentMonth() && d <= moment().date()) {
            continue;
          }
          if (y === maxYear && m === currentMonth() && d > moment().date()) {
            break;
          }
          if (m === 2 && d === 29 && y % 4 !== 0) {
            continue;
          }
          eDD = pad(d, 2);
          for (t = 0, len4 = regions.length; t < len4; t++) {
            r = regions[t];
            e = eYY + eMM + eDD + r;
            e += computeLastDigit(e);
            yield e;
          }
        }
      }
    }
  })();
};

getOptimalRegionPattern = function() {
  var gender, max, min, n, region;
  gender = getGender();
  region = getRegion();
  if (region === '?') {
    switch (gender) {
      case 'M':
        return "??[0-8,2]";
      case 'F':
        return "??[1-9,2]";
      case '?':
        return "???";
    }
  }
  min = regions[region].min;
  max = regions[region].max;
  switch (gender) {
    case 'M':
      return "[" + min + "-" + max + ",2]";
    case 'F':
      n = Number(min[2]) + 1;
      min = min.replace(/.$/, n);
      return "[" + min + "-" + max + ",2]";
    case '?':
      return "[" + min + "-" + max + "]";
  }
};

pad = function(n, s) {
  var l;
  if (s == null) {
    s = 2;
  }
  l = n.toString().length;
  return '0'.repeat(s - l) + n.toString();
};

getOptimalPattern = function() {
  var getOptimalDatePattern;
  getOptimalDatePattern = function() {
    var century, getCentury, maxAge, maxYear, minAge, minYear, months, ref, yearsPattern, yymm;
    ref = getAgeRange(), minAge = ref[0], maxAge = ref[1];
    minYear = moment().year() - maxAge - 1;
    maxYear = moment().year() - minAge;
    getCentury = function(year) {
      return Math.floor(year / 100);
    };
    if (getCentury(minYear) === getCentury(maxYear)) {
      yearsPattern = "[" + (pad(modulo(minYear, 100))) + "-" + (pad(modulo(maxYear, 100))) + "]";
      century = getCentury(maxYear);
      switch (century) {
        case 18:
          months = '[21-32]';
          break;
        case 19:
          months = '[01-12]';
          break;
        case 20:
          months = '[41-52]';
      }
      return "" + yearsPattern + months + "[1-31]";
    }
    switch (false) {
      case !(minYear < 1900 && (1900 <= maxYear && maxYear < 2000)):
        yymm = ("([" + (minYear % 100) + "-99][21-32]") + ("|[00-" + (maxYear % 100) + "][01-12])");
        break;
      case !(minYear < 1900 && 2000 <= maxYear):
        yymm = ("([" + (minYear % 100) + "-99][21-32]") + "|[00-99][01-12]" + ("|[00-" + (maxYear % 100) + "][41-52])");
        break;
      case !((1900 <= minYear && minYear < 2000) && 2000 <= maxYear):
        yymm = ("([" + (minYear % 100) + "-99][01-12]") + ("|[00-" + (maxYear % 100) + "][41-52])");
    }
    return yymm + "[1-31]";
  };
  return "" + (getOptimalDatePattern()) + (getOptimalRegionPattern()) + "?";
};

getOrPatterns = function(pattern) {
  var newPatterns, orGroup, subGroups;
  orGroup = pattern.match(/\([^()]+?\)/);
  if (!orGroup) {
    return pattern;
  }
  subGroups = orGroup[0].replace(/^\(|\)$/g, '').split('|');
  newPatterns = subGroups.map(function(g) {
    return pattern.replace(orGroup, g);
  });
  return newPatterns.flatMap(getOrPatterns);
};

product = function(arrays) {
  var productOfTwo;
  productOfTwo = function(xs, ys) {
    return xs.map(function(x) {
      return ys.map(function(y) {
        if (Array.isArray(x)) {
          return x.concat([y]);
        } else {
          return [x].concat([y]);
        }
      });
    }).reduce(function(acc, arr) {
      return acc.concat(arr);
    });
  };
  return arrays.reduce(productOfTwo);
};

getPatternLength = function(pattern) {
  var subRange;
  subRange = function(unused, r) {
    switch (false) {
      case !/\[\d+-\d+(,\d+)?\]/.test(r):
        return r.match(/\[\d+-(\d+)(,\d+)?\]/)[1];
      case !/\[\d+(,\d+)+\]/.test(r):
        return _.max(r.match(/\[(.+)\]/)[1].split(',').map(Number)).toString();
    }
  };
  return pattern.replace(/\*/g, '').replace(/(\[.+?\])/g, subRange).length;
};

parseRange = function(range) {
  var end, gs, len, ns, ref, ref1, start, step;
  if (range.match(/\[\d+(,\d+)+\]/)) {
    gs = range.match(/\d+/g);
    ns = gs.map(Number);
    len = Math.max.apply(Math, gs.map(function(g) {
      return g.length;
    }));
    return ns.map(function(n) {
      var str;
      str = n.toString();
      return '0'.repeat(len - str.length) + str;
    });
  } else {
    ref = range.match(/\d+/g), start = ref[0], end = ref[1], step = ref[2];
    len = Math.max(start.length, end.length);
    ref1 = [start, end, step].map(Number), start = ref1[0], end = ref1[1], step = ref1[2];
    if (step == null) {
      step = 1;
    }
    return _.range(start, end + 1, step).map(function(n) {
      var str;
      str = n.toString();
      return '0'.repeat(len - str.length) + str;
    });
  }
};

getPatternsFromRangeModel = function(model) {
  var groups;
  if (getPatternLength(model) > 10) {
    return [];
  }
  groups = model.match(/[\d\?]+|\[.+?\]/g).map(function(g) {
    if (g.match(/\[.+?\]/)) {
      return parseRange(g);
    } else {
      return [g];
    }
  });
  return product(groups).map(function(x) {
    if (x.join) {
      return x.join('');
    } else {
      return x;
    }
  });
};

starPattern = function(pattern) {
  var fst, gs, j, l, lst, ref;
  pattern = pattern.replace(/\*{2,}/g, '*');
  l = 10 - getPatternLength(pattern);
  if (l <= 0) {
    return [];
  }
  ref = pattern.split('*'), fst = ref[0], gs = 3 <= ref.length ? slice.call(ref, 1, j = ref.length - 1) : (j = 1, []), lst = ref[j++];
  return cartesian([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], l).flatMap(function(xs) {
    var k, results;
    return combinations((function() {
      results = [];
      for (var k = 0; 0 <= l ? k <= l : k >= l; 0 <= l ? k++ : k--){ results.push(k); }
      return results;
    }).apply(this), gs.length).map(function(ps) {
      return [fst].concat(slice.call(fillAllPos(xs, gs, ps)), [lst]).join('');
    });
  });
};

swapTwoDigits = function(digits) {
  var j, ref, results;
  return (function() {
    results = [];
    for (var j = 0, ref = digits.length - 2; 0 <= ref ? j <= ref : j >= ref; 0 <= ref ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this).map(function(i) {
    return parseEgn(digits.slice(0, i) + digits[i + 1] + digits[i] + digits.slice(i + 2));
  });
};

remove = function(item, arr) {
  var copy, i;
  copy = arr.slice();
  i = copy.indexOf(item);
  if (i !== -1) {
    copy.splice(i, 1);
  }
  return copy;
};

Array.prototype.flatMap = function(f) {
  return this.map(f).reduce((function(acc, arr) {
    return acc.concat(arr);
  }), []);
};

Array.prototype.unique = function() {
  var j, key, output, ref, results, value;
  output = {};
  for (key = j = 0, ref = this.length; 0 <= ref ? j < ref : j > ref; key = 0 <= ref ? ++j : --j) {
    output[this[key]] = this[key];
  }
  results = [];
  for (key in output) {
    value = output[key];
    results.push(value);
  }
  return results;
};

permutations = function(xs) {
  if (xs.length === 1) {
    return [xs];
  } else {
    return xs.unique().flatMap(function(x) {
      return permutations(remove(x, xs)).map(function(p) {
        return [x].concat(p);
      });
    });
  }
};

combinations = function(xs, n) {
  var head, ref, tail;
  if (n === 0) {
    return [[]];
  }
  if (xs.length === 0) {
    return [];
  }
  ref = [xs[0], xs.slice(1)], head = ref[0], tail = ref[1];
  return combinations(tail, n - 1).map(function(c) {
    return [head].concat(c);
  }).concat(combinations(tail, n));
};

combinationsWithRepetitions = function(xs, n) {
  var head, ref, tail;
  if (n === 0) {
    return [[]];
  }
  if (xs.length === 0) {
    return [];
  }
  ref = [xs[0], xs.slice(1)], head = ref[0], tail = ref[1];
  return combinations(xs, n - 1).map(function(c) {
    return [head].concat(c);
  }).concat(combinationsWithRepetitions(tail, n));
};

fixWrongDigits = function(n) {
  return function(digits) {
    var changeDigit, changeDigits;
    digits = parseEgn(digits);
    changeDigit = function(p, n, xs) {
      return xs.slice(0, p).concat([n]).concat(xs.slice(p + 1));
    };
    changeDigits = function(ps, ns, xs) {
      if (ps.length === 0 || ns.length === 0) {
        return xs;
      } else {
        return changeDigits(ps.slice(1), ns.slice(1), changeDigit(ps[0], ns[0], xs));
      }
    };
    return combinations([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], n).flatMap(function(ps) {
      var gs;
      gs = ps.map(function(p) {
        return remove(digits[p], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
      });
      if (gs.length === 1) {
        return gs[0].map(function(n) {
          return changeDigits(ps, [n], digits);
        });
      } else {
        return product(gs).map(function(ns) {
          return changeDigits(ps, ns, digits);
        });
      }
    });
  };
};

tooManyDigits = function(digits) {
  var j, ref, results;
  digits = parseEgn(digits);
  return combinations((function() {
    results = [];
    for (var j = 0, ref = digits.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this), digits.length - 10).map(function(ps) {
    var j, ref, results;
    return (function() {
      results = [];
      for (var j = 0, ref = digits.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).filter(function(i) {
      return !(indexOf.call(ps, i) >= 0);
    }).map(function(i) {
      return digits[i];
    });
  });
};

egnPermutations = function(digits) {
  return permutations(parseEgn(digits));
};
